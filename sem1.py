# Сегодня начнем знакомство с Python
# '#' -- значок для комментария

#Выполнение кода начинается с первой строчки

#Отдадим дань традиции и начнем знакомство с Python с Hello, World!
#Вывод в консоль происходит с помощью функции print
print("Hello, World!") # ; - не надо
#Можно и по-русски
print("Привет, Мир!") # Каждый print переводит вывод на новую строку
#print обладает рядом доп функций, о них позже

#В пайтоне не обязательно указывать тип переменной:

some_var = 12 # ';' в конце строки не нужна 
print(some_var, type(some_var))
#Более того, можно менять тип переменной
some_var = 1.25
print(some_var, type(some_var))
#Такое поведение называется ДИНАМИЧЕСКОЙ ТИПИЗАЦИЕЙ. В С++ типизация СТАТИЧЕСКАЯ

# Тип переменных можно указывать, это называется аннотированием. 
# Аннотирование считается хорошей практикой, которая делает код самодокументируемым


x:int = 1 
y:float = 1/5
l:bool = True
cn:complex = 1+2j

#При этом инты могут быть ОЧЕНЬ большие
x = 10**100 # ** - операция возведения в степень
print(x)

# Ввод производится функцией input
res = input()
print(res, type(res))
# Как видите, тип выводв - str. Т.е. строка
# Работу со строками мы рассмотрим позже

# Можно преобразовать вывод в другой тип: 
res = int(input()) #точно также можно преобразовать в float или другой тип

# Теперь освоим оператор ветвления:
res = int(input())

if(res < 0):
    print("Отрицательное")# все, что написано с 4 отступами - в теле if'a
elif(res == 0):
    print("Нуль")
else:
    print("Отрицательное")

# Списки
# Для хранения множества данных в Python используются списки (list)
# Синтаксис - похож на Си, внутреннее устройство - отличается

lst:list = [1,2,3,4,5,6]
print("1-ый:", lst[0], " 2-ой:", lst[1], 
      " последний:", lst[-1], " предпоследний:", lst[-2])

# В списках можно хранить объекты произвольных типов:
lst[0] = "а я не int"
print(lst[0])

# Если хотим вывести весь список, то надо воспользоваться циклом
for element in lst:
    print(element)
# Как видите, можно обойтись без индексации. 
# Если она все таки нужна, то можно воспользвоаться range

for i in range(0, 10):
    print(i**2)

# А на самом деле, можно и вообще без цикла
print(lst)

# вычисление чисел Фиббоначи:

n = int(input("Введите неотрицательное целое число "))


prev, cur = 1, 1
if n < 0:
    print("False n")
else:
    for i in range(3, n):
        prev, cur = cur, cur+prev
print(cur)

def fib(n:int) -> int:
    prev, cur = 1, 1
    if n < 0:
        print("False n")
        return None
    else:
        for i in range(3, n):
            prev, cur = cur, cur+prev
    return cur

print(fib(n))


# Строки
string:str = "Я маленькая строчка"
print(string)
# Обратиться к конкретному символу можно также, как в списке, по индексу:
char = string[2]
print(char, type(char))
# как видим у "символов" тоже тип str
# В этом отличие от Си: даже один символ - это строка. Пусть и длиной 1
# кстати, узнать длину строки/списка можно при помощи функции len

print("Длина string: ", len(string), ", Длина char: ", len(char),
       ", Длина lst: ", len(lst))




"""
some_list = [1, 2, 4, 5, 6]
some_list = [str(i) for i in some_list]
print("1, 2, 3, 4".split(", "))
print("__".join(some_list))

c:str = "А char'ов нет"

#вывести это все можно с помощью print
print(x,y,c,l,cn, sep="-")




#давайте посмотрим тип переменной с помощью функции type
print(x, type(x)) #print -- выводит в консоль текст

#Python -- язык с динамической типизацией 
#Это значит, что можно абсолютно законно присвоить переменной значение другого типа
x = 1.005
print(x, type(x))
#Или даже так
x = "voyage voyage"
print(x, type(x))
#Здесь мы записали в x строку
#В Python строку можно заключать как в "", так и в ''
#P.S. нет типа char --- символ - это строка длины 1

#можно получить i-ый символ с помощью []
index = int(input("Введите индекс:")) #input() -- считывает с консоли
#по умолчанию input возвращает строку, надо привести ее к int'у
print(x[index])

#нельзя изменить символ в строке
#x[index] = 'N' # -- ошибка

#зато строки можно складывать и умножать
print(string := "раз строка" + " и два строка ")
print(string*10)


#операции приведения типов позволяют легко переключаться между строковым и числовым представлениями
to_float = "1.2345"
to_str = 10**10

to_float = float(to_float)
to_str = str(to_str)

print("Тип to_float: " + str(type(to_float)) + 
      ", тип to_str:" + str(type(to_str)))






#Переменные, это хорошо, а как написать функцию?
#Давайте рассмотрим на примере функции, которая вычисляет n-ое число Фибоначи:

def fib(n:int) -> int|None:
    prev, cur = 1, 1
    if n < 0:
        print("False n")
        return

    else:
        for i in range(3, n):
            prev, cur = cur, cur+prev
    return cur

print("Результат от 0: ", fib(-1))
print("Результат от 10: ", fib(10))

# по умолчанию Python поддерживает самые нужные контейнеры
# список (странный нейминг -- по внутреннему устройству это скорее вектор)
lst2 = list()
lst = [1,2,3,4,5,6,"7",8,9,10]#можно хранить данные разных типов (но нужно ли?)
print(lst[1])

# tuple - кортеж - неизменяемый список
tpl = (1,2,3,4,4,3,2,1)
print(tpl[1])
#tpl[0] = -1 #--- ошибка!

# dict - словарь - аналог map
# хранит пары ключ:значения
# ключи должны иметь неизменяемый тип

dct = {"first": 1, 2:"два", "list":lst, (1,1):1}
print(dct["first"])

# set - множество
#set -- множество
#удобно, когда нужно получить уникальные значения из какого-то контенера
to_set = [1]+2*[2]+3*[3]+4*[4]
st = set(to_set)
print(st.pop())

squared = []
for item in lst:
    if type(item) is int:
        squared.append(item**2) #обратите внимание -- есть встроенный оператор возведения в степень
    else:
        squared.append(int(item)**2)
print(squared)

# списки в питоне поддерживают слайсинг
# используя слайсинг (срезы) можно создавать новые списки 
# на основе существующих
print(lst[2:6]) #здесь создали список от 2-го до 6-го элементов
# можно делать слайсы с шагом, который отличается от 1
print(lst[1:-1:2])#если хотите включить последний элемент: просто убираем -1 (т.е 0::2)
# шаг тоже может быть отрицательным
print(lst[-1:1:-2])

# Вопрос: как развернуть список с помощью слайсинга?
#

# кстати, для строк это тоже работает
x=x[0:index]+"N"+x[index+1:]
print(x)


# итерируемся по словарю
for key in dct:
    print(f"Key is {key}, value is {dct[key]}")

#можно воспользоваться функцией enumirate, чтобы получать номер каждой итерации
for i, key in enumerate(dct):
    print(f"Key is {key}, key number is {i}, value is {dct[key]}")


#comprehension
#часто нам нужно создать один список на основе другого (необязательно списка)
#например возвести элементы в квадрат
#на этом занятии мы уже делали это с помощью цикла
#
#В Pyton есть специальный механизм, который позволяет сделать это одной строкой: list comprehension

squared_set = [i**2 for i in st]

#Если бы делали через цикл:
squared_set = []
for item in squared_set:
    squared_set.append[item**2]

#Если бы мы попробовали сделать такое с lst, то получили бы ошибку -- там есть один элемент строка
#Но можно отсеивать некоторые элементы с помощью if 
lst = [1,2,3,4,5,6,"7",8,9,10]
squared_lst = [i**2 for i in lst if isinstance(i, int)] 
#или так
squared_lst = [i**2 for i in lst if not isinstance(i, str)] 
#Но в данном варианте мы теряем "7", хотя это легко привести к int
full_sl = [i**2 if isinstance(i, int) else int(i)**2 for i in lst]
#вот такие ужасные вещи можно делать в Питоне

#есть также dict comprehension

numbers = {i:str(i) for i in range(0, 10)}

pass
def f():
    pass
"""