#Сегодня начнем знакомство с Python
# '#' -- значок для комментария

#Выполнение кода начинается с первой строчки

#В пайтоне не обязательно указывать тип переменной:
x = 1 # ';' в конце строки не нужна 

#давайте посмотрим тип переменной с помощью функции type
print(type(x)) #print -- выводит в консоль текст

#Python -- язык с динамической типизацией 
#Это значит, что можно абсолютно законно присвоить переменной значение другого типа
x=1.005
print(type(x))
#Или даже так
x="voyage voyage"
print(type(x))
#Здесь мы записали в x строку
#В Python строку можно заключать как в "", так и в ''
#P.S. нет типа char --- символ - это строка длинны 1

#можно получить i-ый символ с помощью []
index = int(input()) #input() -- считывает с консоли
#по умолчанию input возвращает строку, надо привести ее к int'у
print(x[index])

#нельзя изменить символ в строке
#x[index] = 'N' # -- ошибка

#чтобы добиться нужного результата,
#придется создавать новую строку
x=x[0:index]+"N"+x[index+1:-1]

#операции приведения типов позволяют легко переключаться между строковым и числовым представлениями
to_float = "1.2345"
to_str = 10**10

to_float = float(to_float)
to_str = str(to_str)

print("Тип to_float: " + str(type(to_float)) + 
      ", тип to_str:" + str(type(to_str)))

#Переменные, это хорошо, а как написать функцию?
#Давайте рассмотрим на примере функции, которая вычисляет n-ое число Фибоначи:

def fib(n):
    prev, cur = 1, 1
    if n < 0:
        print("False n")
        return
    for i in range(3, n):
        prev, cur = cur, cur+prev
    return cur

print("Результат от 0: ", fib(-1))
print("Результат от 10: ", fib(10))

#по умолчанию Python поддерживает самые нужные контейнеры
#список (станный нейминг -- по внутреннему устройству это скорее вектор)
lst = [1,2,3,4,5,6,"7",8,9,10]#можно хранить данные разных типов (но нужно ли?)

#Список поддерживает []
print(lst[2])
#используя слайсинг (срезы) можно создавать новые списки на основе существующих
print(lst[2:6]) #здесь создали список от 2-го до 6-го элементов
#можно делать слайсы с шагом, который отличается от 1
print(lst[1:-1:2])#если хоти включить последний элемент: просто убираем -1 (т.е 0::2)
#шаг тоже может быть отрицательным
print(lst[-1:1:-2])
#Вопрос: как развернуть список с помощью слайсинга?
#

squared = []
for item in lst:
    if item is int:
        squared.append(item**2) #обратите внимание -- есть встроенный оператор возведения в степень
    else:
        squared.append(int(item)**2)
print(squared)

#tuple -- как лист, но нельзя менять его значения
tpl = (1,2,3)
#tpl[0] #--- ошибка!

#dict --  словарь (в С++ назывался map)
#хранит пары ключ:значения
#ключи должны иметь неизменяемый тип

str_dict = {"first":1, "second":2, "third":"3"}
int_dict = {1:"1", 2:"2", 3:"3"}
strange_dict = {tpl:"tpl", (1,1):"another one tuple", "wow_key is a str": str_dict}

#итерируемся по словарю
for key in str_dict:
    print(f"Key is {key}, value is {str_dict[key]}")

#можно воспользоваться функцией enumirate, чтобы получать номер каждой итерации
for i, key in enumerate(str_dict):
    print(f"Key is {key}, key number is {i}, value is {str_dict[key]}")

#set -- множество
#удобно, когда нужно получить уникальные значения из какого-то контенера
to_set = [1]+2*[2]+3*[3]+4*[4]
st = set(to_set)

#comprehension
#часто нам нужно создать один список на основе другого (необязательно списка)
#например возвести элементы в квадрат
#на этом занятии мы уже делали это с помощью цикла
#
#В Pyton есть специальный механизм, который позволяет сделать это одной строкой: list comprehension

squared_set = [i**2 for i in st]

#Если бы делали через цикл:
squared_set = []
for item in squared_set:
    squared_set.append[item**2]

#Если бы мы попробовали сделать такое с lst, то получили бы ошибку -- там есть один элемент строка
#Но можно отсеивать некоторые элементы с помощью if 
lst = [1,2,3,4,5,6,"7",8,9,10]
squared_lst = [i**2 for i in lst if isinstance(i, int)] 
#или так
squared_lst = [i**2 for i in lst if not isinstance(i, str)] 
#Но в данном варианте мы теряем "7", хотя это легко привести к int
full_sl = [i**2 if isinstance(i, int) else int(i)**2 for i in lst]
#вот такие ужасные вещи можно делать в Питоне

#есть также dict comprehension

numbers = {i:str(i) for i in range(0, 10)}

pass
