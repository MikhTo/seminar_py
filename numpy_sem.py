# Сегодня знакомимся с библиотекой numpy - numerical python
# Numpy написана на С, что обеспечивает высокую скорость вычислений
# Numpy лежит в основе многих научных библиотек и пользуется заслуженной популярностью среди исследователей 

#Подключаем библиотеку
import numpy as np

#может так статься, что у вас не найдется эта библиотека - она не стандартная
#тогда ее нужно установить 
#WINDOWS: conda install numpy
#LINUX: pip install numpy

#основной объект, используемый в numpy - numpy.ndarray - многомерный массив
#чаще всего используются одномерные (векторы) и двумерные (матрицы)

arr = np.array([1,2,3])

print(f"Тип arr: {type(arr)}")

#можно узнать различные параметры нашего ndarray

print(f"Форма: {arr.shape}, размерность: {arr.ndim}, размер: {arr.size}, тип хранимых значений: {arr.dtype}")

#Обращение к элементам такое же, как в у обычного списка - через []

matr = np.array([[11.,12., 13.], [21., 22., 23.], [31., 32., 33.]])

print(f"Форма: {matr.shape}, размерность: {matr.ndim}, размер: {matr.size}, тип хранимых значений: {matr.dtype}")

#обратите внимание, что есть два способа задать вектор

print(f"вектор: {np.array([1, 2, 3]).shape}, \"одномерная матрица\": {np.array([[1,2,3]]).shape}")

#Рассмотрим некоторые удобные способы создавать ndarray

#можно создать ndarray, заполненный нулями

zero_arr = np.zeros(shape=(7,))

#заполненный единицами
ones_matr = np.ones((10, 10), dtype= np.int8) #есть int'ы от 8 до 256 бит (float'ы тоже)

#"пустой" - на самом деле заполненный "мусором"
empty_tens = np.empty(shape = (3,3,3)) #трехмерный тензор 3х3х3

lin_arr = np.linspace(0, 10 , 20) #первые два аргумента - диапозон, третий - количество элемнтов. 
#точно знаем размер

agar = np.arange(10, 20, 2) #начало, конец, шаг
#точно знаем шаг

#индексация

matr = np.array([[11.,12., 13.], [21., 22., 23.], [31., 32., 33.]])

#чтобы обратиться к элементу матрицы пишем индексы через запятую

#третья строка, первый столбец
print(f"первая строка, третий столбец: {matr[2,0]}")

#вторая строка
print(f"вторая строка: {matr[1, :]}") #или так matr[1]

#третий столбец
print(f"третий столбец: {matr[:, 2]}")

#а теперь вырежем матрицу 2х2 в правом нижнем углу

print(f"матрица 2х2: {matr[1:3,1:3]}")

#можно устанавливать шаг
print(f"матица с шагом 2: {matr[::2,::2]} - отсутствует вторая строка и столбец")

#операции с ndarray

#определены операции сложения, вычитания, умножения, деления, возведения в степень и т.п.
#При этом умножение поэлементное: с = a * b => a[i,j] = a[i,j] * b[i, j]

mult_mat = matr*matr
# можно умножать на константу, столбец или строку с совпадающим размером - broadcasting 
mult_mat /= 2

mult_mat *= np.array([1,2,3])

#также для ndarray определены операции сравнения
matr = np.array([[1, -1, 1], [-1, 1, -1], [1, -1, 1]])

mask = matr > 0 

#с помощью получившейся булевой маски можно выбрать элементы

res = matr[mask]
#можно и для других масок, главное, чтобы размер совпадал

res = mult_mat[matr<0]

#обратите внимение - результат является вектором - размерность не совпадает с исходной матрицей!


#основы работы с numpy мы рассмотрели, теперь давайте обсудим полезные методы и функции

#например в прошлом примере мы видели, что при использовании булевой маски у нас не сохранятеся исходная размерность
#это можно исправить, если использовать функцию np.where

res = np.where(mask, mult_mat, 0) #нужно указать, какое значение брать, если условие не выполняется

# функции np.hstack и np.vstack "склеивают" два np.ndarray
# необходимо, что размерность, по которой идет склейка, была одинакова

# сделаем матрицу, добавив первый столбец матрицы res в качестве последней строки

first_col = mult_mat[:,0].reshape(3, -1)
res = np.hstack((mult_mat, first_col)) #заметим, что передаем кортеж из ndarray'ев, которые хотим объединить
#P.S. их может быть не два, а больше

# reshape - функция, которая изменяет форму массива
# аргументы - размерность, к которой приводим
# аршументы -1 отвечают автовыбору
# например, если применим к ndarray с размерностью (16, 1) reshape(4,-1), 
# то получим ndarray с размерностью (4, 4), а если reshape(2, -1), то с размерностью (2, 8)

#теперь "склеим" последний столбец с остальной матрицей

res = np.vstack((res[2], res))


# также есть стат функции среднего квадратичного отклонения и среднего
print(f"Среднее: {res.mean()}, СКО: {res.std()}")
# есть также отдельные функции np.mean() и np.std()
# в рамках семинара мы рассмотрели лишь функции, которые вам пригодятся для рещения задач
# и при этом не прописанных в указаниях к задачам


pass