
#В прошлый раз не рассказали о сортировках: исправляемся

#сделаем список 
some_list = list(range(-7, 7, 1))
#и перемешаем его с помощью функции shuffle из библиотеки random
from random import shuffle
shuffle(some_list)

#можно либо создать новый список с помощью функции sorted 
new_list = sorted(some_list)
#либо отсортировать сам список с помощью метода sort
some_list.sort()
#сортировка в обратном порядке
some_list.sort(reverse=True)
#можно создать сортировку по более сложному критерию
#например по модулю
#для этого надо передать с аргументом key функцию, которая будет применяться к каждому элементу
some_list.sort(key=lambda x: abs(x))

#примерно также можно работать с функциями max и min
min_el = min(some_list)
min_el = min(some_list, key=lambda x: abs(x))

#контрольная задача: как отсортировать по четности?


#Стоки и работа с текстом
some_string = "это какая-то строка для демонстрации работы со строками в языке Python"

some_string = some_string.replace("*", "о", 1)

print(some_string.split("-")) #разделяем по разделителю

#в физике мы часто сталкиваемся с csv-форматом хранения чисел
#c ним можно легко справиться с помощью .split

csv_string = "1,2,3,5,7,8,9,0,10"
#хотим превратить это в список чисел

#можно через list comprehension
csv_res1 = [int(s) for s in csv_string.split(",")]
#можно через map
gen_obj = map(int, csv_string.split(","))
csv_res2 = list(gen_obj) #Здесь мог быть любой другой контейнер

#поиск
index = some_string.find("то", some_string.find("о"))
#подсчет вхождений
amount = some_string.count("о")
#очень полезная функция, можно создать счетчик
counter = {symb:some_string.count(symb) for symb in set(some_string)}

another_string = "\n    куча пробельных символов вокруг \n\t"
another_string = another_string.strip()

#raw-строки
raw_string = r'\n любые спец символы теперь просто символы \n\t'

#часто при описании работы r-строк говорят, что специальные символы экранируются 
#raw-строки удобно использовать при работе с файловой системой и запросах в сеть

#про работу с интернетом поговорим на одном из следующих занятий, 
# а сейчас посмотрим, как можно манипулировать файлами с помощью Python

#os -- библиотека для работы с файловой системой
import os

print(os.curdir) #или .getcwd()
for i in range(3):
    os.mkdir(f"dir{i}")
#при попытке создать уже существующую папку получим ошибку!
#получаем с помощью isdir
print(f"Папка dir3 существует: {os.path.isdir('dir2')}, папка dir4 существует: {os.path.isdir('dir3')}")
#перейдем в папку dir
os.chdir(r".\dir1")
#и создадим файлов в ней
for i in range(3):
    os.popen(rf"copy ..\empty_file.txt file{i}.txt")# "команда путь_до_файла куда_скопировать"
os.chdir("..")
#сделали папки и файлы, теперь удалим
for file in os.listdir(r".\dir1"):
    os.remove(os.path.join("dir1",file))
for dir in os.listdir():
    if "dir" in dir: #обратите внимание, как мы ищем вхождение
        os.rmdir(dir) #только для пустых папок!

# работа с файлами

#откываем файл
f = open("test_read.txt", "r", encoding = "utf-8") # encoding - необязательный параметр
# 'r' - чтение, 'w' - запись (старое содержимое файла стирается), 'a' - дозапись

#можно считать так:
text = f.read()

f.close()

f = open("test_read.txt", "r", encoding = "utf-8")
#А можно так:
text = []
for line in f:
    text.append(line)

f.close()

#чтобы не забывать закрыть файл можно его открыть с помощью with as
with open("test_read.txt", encoding="utf-8") as tr, open("empty_file.txt", "w", encoding="utf-8") as ef:
    text = " ".join(tr) #данный метод создает строку,
    #составленную из элементов контейнера, разделенных исходной строкой
    ef.write(text)
#with -- мененджер контекста 
#вот так, кстати, подключаются библиотеки
import re

#давайте создадим патерн, чтобы узнать, как много у Ландау слов "очевидно"
pattern = r"\b([оО]чевидно)\b" #\b - знак конца слова
# [] - подходит любой из символов внутри скобок
# () - группировка, чтобы в ответ попало то, что внутри скобок

#чтобы вызвать функцию из библиотеки нужно перед ней, разделяя точкой, имя самой библиотеки

obv = re.findall(pattern, text)
print("слов очевидно: "+ str(len(obv)) + " станиц: 515 => уровень очевидности: "+ str((len(obv)/515)*100) + "%")

#Маловато! Давайте заменим все слова, начинающиеся с "о" и заканчивающиеся на "о" словом "очевидно"

pattern = r"\b([Оо][а-яА-Я]*о)\b" #[а-яА-Я] - любая русская буква, * - любое количество
# P.s. для поиска английских можно использовать \w - очень удобно

text = re.sub(pattern, "очевидно", text)

obv = re.findall(r"\b([оО]чевидно)\b", text)
print("Новый уровень очевидности: " + str((len(obv)/515)*100) + "%")

#Как видете, очень удобно!
# другие полезные обозначения:
# * - сколько угодно символов, + - один или больше, ? - один или ноль
# . - любой символ, \w - любая англ. буква, \d - любая цифра, \s - любой пробел
# Это, конечно, далеко не все возможности регулярок

#однако стоит помнить, что легко ошибиться в создании паттерна
#Одно из мудрейших изречений:

# Некоторые люди, сталкиваясь с проблемой, думают: 
# «Я знаю, я буду использовать регулярные выражения!». 
# Теперь у них две проблемы.

#f-строки
# Когда мы высчитывали, уровень очевидности Ландау, приходилось писать сл. выражение
# print("слов очевидно: "+ str(len(obv)) + " станиц: 515 => уровень очевидности: "+ str((len(obv)/515)*100) + "%")
# Неудобно!
# для таких целей придуманы форматирванные строки

print(f"слов очевидно:{len(obv)}  станиц: 515 => уровень очевидности: {(len(obv)/515)*100}%")

#Возможности форматированнния гораздо шире, чем просто подстановка значений

#можно указывать ширину
print(f"раз число: {10: 10d}, два число: {10: 5d}")

#попросить вывести знак:

print(f"десять {10}, еще десять {10:+}, минус десять {-10} ")

#или вывести с определенной точностью:
e = 2.7182818284
print(f"e: {e:.3f}, тоже e: {e:.5f}")

#это, конечно, далеко не все возможности. Остальные всегда можно отыскать в интернете 


